
-- generated by elm_rs


module Bindings exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]
        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type InfluxResourceId
    = SerialId (Int)
    | StringId (String)


influxResourceIdEncoder : InfluxResourceId -> Json.Encode.Value
influxResourceIdEncoder enum =
    case enum of
        SerialId inner ->
            Json.Encode.object [ ( "SerialId", Json.Encode.int inner ) ]
        StringId inner ->
            Json.Encode.object [ ( "StringId", Json.Encode.string inner ) ]

type alias LanguageEntry =
    { id : Maybe (InfluxResourceId)
    , identifier : String
    , code : String
    , name : String
    , dicts : List (String)
    }


languageEntryEncoder : LanguageEntry -> Json.Encode.Value
languageEntryEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "identifier", (Json.Encode.string) struct.identifier )
        , ( "code", (Json.Encode.string) struct.code )
        , ( "name", (Json.Encode.string) struct.name )
        , ( "dicts", (Json.Encode.list (Json.Encode.string)) struct.dicts )
        ]


type DocType
    = Text
    | Video
    | Audio


docTypeEncoder : DocType -> Json.Encode.Value
docTypeEncoder enum =
    case enum of
        Text ->
            Json.Encode.string "Text"
        Video ->
            Json.Encode.string "Video"
        Audio ->
            Json.Encode.string "Audio"

type alias DocMetadata =
    { title : String
    , docType : DocType
    , tags : List (String)
    , dateCreated : String
    , dateModified : String
    }


docMetadataEncoder : DocMetadata -> Json.Encode.Value
docMetadataEncoder struct =
    Json.Encode.object
        [ ( "title", (Json.Encode.string) struct.title )
        , ( "doc_type", (docTypeEncoder) struct.docType )
        , ( "tags", (Json.Encode.list (Json.Encode.string)) struct.tags )
        , ( "date_created", (Json.Encode.string) struct.dateCreated )
        , ( "date_modified", (Json.Encode.string) struct.dateModified )
        ]


type alias DocEntry =
    { path : String
    , filename : String
    , metadata : DocMetadata
    }


docEntryEncoder : DocEntry -> Json.Encode.Value
docEntryEncoder struct =
    Json.Encode.object
        [ ( "path", (Json.Encode.string) struct.path )
        , ( "filename", (Json.Encode.string) struct.filename )
        , ( "metadata", (docMetadataEncoder) struct.metadata )
        ]


influxResourceIdDecoder : Json.Decode.Decoder InfluxResourceId
influxResourceIdDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.map SerialId (Json.Decode.field "SerialId" (Json.Decode.int))
        , Json.Decode.map StringId (Json.Decode.field "StringId" (Json.Decode.string))
        ]

languageEntryDecoder : Json.Decode.Decoder LanguageEntry
languageEntryDecoder =
    Json.Decode.succeed LanguageEntry
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "identifier" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "code" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "name" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "dicts" (Json.Decode.list (Json.Decode.string))))


docTypeDecoder : Json.Decode.Decoder DocType
docTypeDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "Text" ->
                            Json.Decode.succeed Text
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "Video" ->
                            Json.Decode.succeed Video
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "Audio" ->
                            Json.Decode.succeed Audio
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

docMetadataDecoder : Json.Decode.Decoder DocMetadata
docMetadataDecoder =
    Json.Decode.succeed DocMetadata
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "title" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "doc_type" (docTypeDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tags" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "date_created" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "date_modified" (Json.Decode.string)))


docEntryDecoder : Json.Decode.Decoder DocEntry
docEntryDecoder =
    Json.Decode.succeed DocEntry
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "path" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "filename" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "metadata" (docMetadataDecoder)))


