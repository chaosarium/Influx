
-- generated by elm_rs


module Bindings exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]
        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type InfluxResourceId
    = SerialId (Int)
    | StringId (String)


influxResourceIdEncoder : InfluxResourceId -> Json.Encode.Value
influxResourceIdEncoder enum =
    case enum of
        SerialId inner ->
            Json.Encode.object [ ( "SerialId", Json.Encode.int inner ) ]
        StringId inner ->
            Json.Encode.object [ ( "StringId", Json.Encode.string inner ) ]

type alias Language =
    { id : Maybe (InfluxResourceId)
    , name : String
    , dicts : List (String)
    , ttsRate : Maybe (Float)
    , ttsPitch : Maybe (Float)
    , ttsVoice : Maybe (String)
    , deeplSourceLang : Maybe (String)
    , deeplTargetLang : Maybe (String)
    , parserConfig : ParserConfig
    }


languageEncoder : Language -> Json.Encode.Value
languageEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "name", (Json.Encode.string) struct.name )
        , ( "dicts", (Json.Encode.list (Json.Encode.string)) struct.dicts )
        , ( "tts_rate", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.float)) struct.ttsRate )
        , ( "tts_pitch", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.float)) struct.ttsPitch )
        , ( "tts_voice", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.ttsVoice )
        , ( "deepl_source_lang", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.deeplSourceLang )
        , ( "deepl_target_lang", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.deeplTargetLang )
        , ( "parser_config", (parserConfigEncoder) struct.parserConfig )
        ]


type alias ParserConfig =
    { whichParser : String
    , parserArgs : Dict String (String)
    }


parserConfigEncoder : ParserConfig -> Json.Encode.Value
parserConfigEncoder struct =
    Json.Encode.object
        [ ( "which_parser", (Json.Encode.string) struct.whichParser )
        , ( "parser_args", (Json.Encode.dict identity (Json.Encode.string)) struct.parserArgs )
        ]


type alias LanguageCreateRequest =
    { name : String
    , dicts : List (String)
    , ttsRate : Maybe (Float)
    , ttsPitch : Maybe (Float)
    , ttsVoice : Maybe (String)
    , deeplSourceLang : Maybe (String)
    , deeplTargetLang : Maybe (String)
    , parserConfig : ParserConfig
    }


languageCreateRequestEncoder : LanguageCreateRequest -> Json.Encode.Value
languageCreateRequestEncoder struct =
    Json.Encode.object
        [ ( "name", (Json.Encode.string) struct.name )
        , ( "dicts", (Json.Encode.list (Json.Encode.string)) struct.dicts )
        , ( "tts_rate", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.float)) struct.ttsRate )
        , ( "tts_pitch", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.float)) struct.ttsPitch )
        , ( "tts_voice", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.ttsVoice )
        , ( "deepl_source_lang", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.deeplSourceLang )
        , ( "deepl_target_lang", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.deeplTargetLang )
        , ( "parser_config", (parserConfigEncoder) struct.parserConfig )
        ]


type alias Document =
    { id : Maybe (InfluxResourceId)
    , langId : InfluxResourceId
    , title : String
    , content : String
    , docType : String
    , tags : List (String)
    , createdTs : String
    , updatedTs : String
    }


documentEncoder : Document -> Json.Encode.Value
documentEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "lang_id", (influxResourceIdEncoder) struct.langId )
        , ( "title", (Json.Encode.string) struct.title )
        , ( "content", (Json.Encode.string) struct.content )
        , ( "doc_type", (Json.Encode.string) struct.docType )
        , ( "tags", (Json.Encode.list (Json.Encode.string)) struct.tags )
        , ( "created_ts", (Json.Encode.string) struct.createdTs )
        , ( "updated_ts", (Json.Encode.string) struct.updatedTs )
        ]


type alias DocumentCreateRequest =
    { langId : InfluxResourceId
    , title : String
    , content : String
    , docType : String
    , tags : List (String)
    }


documentCreateRequestEncoder : DocumentCreateRequest -> Json.Encode.Value
documentCreateRequestEncoder struct =
    Json.Encode.object
        [ ( "lang_id", (influxResourceIdEncoder) struct.langId )
        , ( "title", (Json.Encode.string) struct.title )
        , ( "content", (Json.Encode.string) struct.content )
        , ( "doc_type", (Json.Encode.string) struct.docType )
        , ( "tags", (Json.Encode.list (Json.Encode.string)) struct.tags )
        ]


type alias DocPackage =
    { documentId : InfluxResourceId
    , languageId : InfluxResourceId
    , document : Document
    , language : Language
    }


docPackageEncoder : DocPackage -> Json.Encode.Value
docPackageEncoder struct =
    Json.Encode.object
        [ ( "document_id", (influxResourceIdEncoder) struct.documentId )
        , ( "language_id", (influxResourceIdEncoder) struct.languageId )
        , ( "document", (documentEncoder) struct.document )
        , ( "language", (languageEncoder) struct.language )
        ]


type alias Token =
    { id : Maybe (InfluxResourceId)
    , langId : InfluxResourceId
    , orthography : String
    , phonetic : String
    , definition : String
    , notes : String
    , originalContext : String
    , status : TokenStatus
    }


tokenEncoder : Token -> Json.Encode.Value
tokenEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "lang_id", (influxResourceIdEncoder) struct.langId )
        , ( "orthography", (Json.Encode.string) struct.orthography )
        , ( "phonetic", (Json.Encode.string) struct.phonetic )
        , ( "definition", (Json.Encode.string) struct.definition )
        , ( "notes", (Json.Encode.string) struct.notes )
        , ( "original_context", (Json.Encode.string) struct.originalContext )
        , ( "status", (tokenStatusEncoder) struct.status )
        ]


type TokenStatus
    = Unmarked
    | L1
    | L2
    | L3
    | L4
    | L5
    | Known
    | Ignored


tokenStatusEncoder : TokenStatus -> Json.Encode.Value
tokenStatusEncoder enum =
    case enum of
        Unmarked ->
            Json.Encode.string "UNMARKED"
        L1 ->
            Json.Encode.string "L1"
        L2 ->
            Json.Encode.string "L2"
        L3 ->
            Json.Encode.string "L3"
        L4 ->
            Json.Encode.string "L4"
        L5 ->
            Json.Encode.string "L5"
        Known ->
            Json.Encode.string "KNOWN"
        Ignored ->
            Json.Encode.string "IGNORED"

type alias Phrase =
    { id : Maybe (InfluxResourceId)
    , langId : InfluxResourceId
    , orthographySeq : List (String)
    , definition : String
    , notes : String
    , originalContext : String
    , status : TokenStatus
    }


phraseEncoder : Phrase -> Json.Encode.Value
phraseEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "lang_id", (influxResourceIdEncoder) struct.langId )
        , ( "orthography_seq", (Json.Encode.list (Json.Encode.string)) struct.orthographySeq )
        , ( "definition", (Json.Encode.string) struct.definition )
        , ( "notes", (Json.Encode.string) struct.notes )
        , ( "original_context", (Json.Encode.string) struct.originalContext )
        , ( "status", (tokenStatusEncoder) struct.status )
        ]


type CardType
    = Recognition
    | Production
    | Cloze


cardTypeEncoder : CardType -> Json.Encode.Value
cardTypeEncoder enum =
    case enum of
        Recognition ->
            Json.Encode.string "RECOGNITION"
        Production ->
            Json.Encode.string "PRODUCTION"
        Cloze ->
            Json.Encode.string "CLOZE"

type CardState
    = Active
    | Suspended
    | Archived
    | Disabled


cardStateEncoder : CardState -> Json.Encode.Value
cardStateEncoder enum =
    case enum of
        Active ->
            Json.Encode.string "ACTIVE"
        Suspended ->
            Json.Encode.string "SUSPENDED"
        Archived ->
            Json.Encode.string "ARCHIVED"
        Disabled ->
            Json.Encode.string "DISABLED"

type alias FsrsLanguageConfig =
    { id : Maybe (InfluxResourceId)
    , langId : InfluxResourceId
    , fsrsWeights : List (Float)
    , desiredRetention : Float
    , maximumInterval : Int
    , requestRetention : Maybe (Float)
    , enabledCardTypes : List (CardType)
    }


fsrsLanguageConfigEncoder : FsrsLanguageConfig -> Json.Encode.Value
fsrsLanguageConfigEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "lang_id", (influxResourceIdEncoder) struct.langId )
        , ( "fsrs_weights", (Json.Encode.list (Json.Encode.float)) struct.fsrsWeights )
        , ( "desired_retention", (Json.Encode.float) struct.desiredRetention )
        , ( "maximum_interval", (Json.Encode.int) struct.maximumInterval )
        , ( "request_retention", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.float)) struct.requestRetention )
        , ( "enabled_card_types", (Json.Encode.list (cardTypeEncoder)) struct.enabledCardTypes )
        ]


type alias Card =
    { id : Maybe (InfluxResourceId)
    , tokenId : Maybe (InfluxResourceId)
    , phraseId : Maybe (InfluxResourceId)
    , cardType : CardType
    , cardState : CardState
    , fsrsMemory : Maybe (SerializableMemoryState)
    , dueDate : Maybe (String)
    , lastReview : Maybe (String)
    }


cardEncoder : Card -> Json.Encode.Value
cardEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "token_id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.tokenId )
        , ( "phrase_id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.phraseId )
        , ( "card_type", (cardTypeEncoder) struct.cardType )
        , ( "card_state", (cardStateEncoder) struct.cardState )
        , ( "fsrs_memory", (Maybe.withDefault Json.Encode.null << Maybe.map (serializableMemoryStateEncoder)) struct.fsrsMemory )
        , ( "due_date", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.dueDate )
        , ( "last_review", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.lastReview )
        ]


type alias ReviewLog =
    { id : Maybe (InfluxResourceId)
    , cardId : InfluxResourceId
    , rating : Int
    , reviewTimeMs : Maybe (Int)
    , fsrsMemoryBefore : Maybe (SerializableMemoryState)
    , fsrsMemoryAfter : Maybe (SerializableMemoryState)
    , reviewDate : String
    }


reviewLogEncoder : ReviewLog -> Json.Encode.Value
reviewLogEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.id )
        , ( "card_id", (influxResourceIdEncoder) struct.cardId )
        , ( "rating", (Json.Encode.int) struct.rating )
        , ( "review_time_ms", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.int)) struct.reviewTimeMs )
        , ( "fsrs_memory_before", (Maybe.withDefault Json.Encode.null << Maybe.map (serializableMemoryStateEncoder)) struct.fsrsMemoryBefore )
        , ( "fsrs_memory_after", (Maybe.withDefault Json.Encode.null << Maybe.map (serializableMemoryStateEncoder)) struct.fsrsMemoryAfter )
        , ( "review_date", (Json.Encode.string) struct.reviewDate )
        ]


type alias SerializableMemoryState =
    { stability : Float
    , difficulty : Float
    }


serializableMemoryStateEncoder : SerializableMemoryState -> Json.Encode.Value
serializableMemoryStateEncoder struct =
    Json.Encode.object
        [ ( "stability", (Json.Encode.float) struct.stability )
        , ( "difficulty", (Json.Encode.float) struct.difficulty )
        ]


type Term
    = TokenTerm (Token)
    | PhraseTerm (Phrase)


termEncoder : Term -> Json.Encode.Value
termEncoder enum =
    case enum of
        TokenTerm inner ->
            Json.Encode.object [ ( "TokenTerm", tokenEncoder inner ) ]
        PhraseTerm inner ->
            Json.Encode.object [ ( "PhraseTerm", phraseEncoder inner ) ]

type TermEditAction
    = CreateTerm
    | UpdateTerm
    | DeleteTerm


termEditActionEncoder : TermEditAction -> Json.Encode.Value
termEditActionEncoder enum =
    case enum of
        CreateTerm ->
            Json.Encode.string "CreateTerm"
        UpdateTerm ->
            Json.Encode.string "UpdateTerm"
        DeleteTerm ->
            Json.Encode.string "DeleteTerm"

type alias GetDocResponse =
    { docPackage : DocPackage
    , annotatedDoc : AnnotatedDocV2
    , termDict : TermDictionary
    }


getDocResponseEncoder : GetDocResponse -> Json.Encode.Value
getDocResponseEncoder struct =
    Json.Encode.object
        [ ( "doc_package", (docPackageEncoder) struct.docPackage )
        , ( "annotated_doc", (annotatedDocV2Encoder) struct.annotatedDoc )
        , ( "term_dict", (termDictionaryEncoder) struct.termDict )
        ]


type alias TermEditRequest =
    { requestedAction : TermEditAction
    , term : Term
    , documentId : Maybe (InfluxResourceId)
    }


termEditRequestEncoder : TermEditRequest -> Json.Encode.Value
termEditRequestEncoder struct =
    Json.Encode.object
        [ ( "requested_action", (termEditActionEncoder) struct.requestedAction )
        , ( "term", (termEncoder) struct.term )
        , ( "document_id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.documentId )
        ]


type alias TermEditResponse =
    { performedAction : TermEditAction
    , term : Term
    , updatedAnnotatedDoc : Maybe (AnnotatedDocV2)
    }


termEditResponseEncoder : TermEditResponse -> Json.Encode.Value
termEditResponseEncoder struct =
    Json.Encode.object
        [ ( "performed_action", (termEditActionEncoder) struct.performedAction )
        , ( "term", (termEncoder) struct.term )
        , ( "updated_annotated_doc", (Maybe.withDefault Json.Encode.null << Maybe.map (annotatedDocV2Encoder)) struct.updatedAnnotatedDoc )
        ]


type alias GetDocsRequest =
    { languageId : Maybe (InfluxResourceId)
    }


getDocsRequestEncoder : GetDocsRequest -> Json.Encode.Value
getDocsRequestEncoder struct =
    Json.Encode.object
        [ ( "language_id", (Maybe.withDefault Json.Encode.null << Maybe.map (influxResourceIdEncoder)) struct.languageId )
        ]


type ReviewableCardId
    = ExistingCard (InfluxResourceId)
    | NewTokenCard { tokenId : InfluxResourceId, cardType : CardType }
    | NewPhraseCard { phraseId : InfluxResourceId, cardType : CardType }


reviewableCardIdEncoder : ReviewableCardId -> Json.Encode.Value
reviewableCardIdEncoder enum =
    case enum of
        ExistingCard inner ->
            Json.Encode.object [ ( "ExistingCard", influxResourceIdEncoder inner ) ]
        NewTokenCard { tokenId, cardType } ->
            Json.Encode.object [ ( "NewTokenCard", Json.Encode.object [ ( "token_id", (influxResourceIdEncoder) tokenId ), ( "card_type", (cardTypeEncoder) cardType ) ] ) ]
        NewPhraseCard { phraseId, cardType } ->
            Json.Encode.object [ ( "NewPhraseCard", Json.Encode.object [ ( "phrase_id", (influxResourceIdEncoder) phraseId ), ( "card_type", (cardTypeEncoder) cardType ) ] ) ]

type alias CardWithTerm =
    { card : Card
    , term : Term
    , isNewCard : Bool
    }


cardWithTermEncoder : CardWithTerm -> Json.Encode.Value
cardWithTermEncoder struct =
    Json.Encode.object
        [ ( "card", (cardEncoder) struct.card )
        , ( "term", (termEncoder) struct.term )
        , ( "is_new_card", (Json.Encode.bool) struct.isNewCard )
        ]


type alias GetNextDueCardRequest =
    { langId : InfluxResourceId
    , cardTypes : Maybe (List (CardType))
    }


getNextDueCardRequestEncoder : GetNextDueCardRequest -> Json.Encode.Value
getNextDueCardRequestEncoder struct =
    Json.Encode.object
        [ ( "lang_id", (influxResourceIdEncoder) struct.langId )
        , ( "card_types", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.list (cardTypeEncoder))) struct.cardTypes )
        ]


type alias GetNextDueCardResponse =
    { card : Maybe (CardWithTerm)
    , remainingDueCount : Int
    }


getNextDueCardResponseEncoder : GetNextDueCardResponse -> Json.Encode.Value
getNextDueCardResponseEncoder struct =
    Json.Encode.object
        [ ( "card", (Maybe.withDefault Json.Encode.null << Maybe.map (cardWithTermEncoder)) struct.card )
        , ( "remaining_due_count", (Json.Encode.int) struct.remainingDueCount )
        ]


type alias SubmitReviewRequest =
    { cardIdentifier : ReviewableCardId
    , rating : Int
    , reviewTimeMs : Maybe (Int)
    }


submitReviewRequestEncoder : SubmitReviewRequest -> Json.Encode.Value
submitReviewRequestEncoder struct =
    Json.Encode.object
        [ ( "card_identifier", (reviewableCardIdEncoder) struct.cardIdentifier )
        , ( "rating", (Json.Encode.int) struct.rating )
        , ( "review_time_ms", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.int)) struct.reviewTimeMs )
        ]


type alias SubmitReviewResponse =
    { updatedCard : Card
    , reviewLog : ReviewLog
    , nextDueDate : String
    , wasNewCard : Bool
    }


submitReviewResponseEncoder : SubmitReviewResponse -> Json.Encode.Value
submitReviewResponseEncoder struct =
    Json.Encode.object
        [ ( "updated_card", (cardEncoder) struct.updatedCard )
        , ( "review_log", (reviewLogEncoder) struct.reviewLog )
        , ( "next_due_date", (Json.Encode.string) struct.nextDueDate )
        , ( "was_new_card", (Json.Encode.bool) struct.wasNewCard )
        ]


type alias UpdateFsrsConfigRequest =
    { newConfig : FsrsLanguageConfig
    }


updateFsrsConfigRequestEncoder : UpdateFsrsConfigRequest -> Json.Encode.Value
updateFsrsConfigRequestEncoder struct =
    Json.Encode.object
        [ ( "new_config", (fsrsLanguageConfigEncoder) struct.newConfig )
        ]


type alias UpdateFsrsConfigResponse =
    { updatedConfig : FsrsLanguageConfig
    }


updateFsrsConfigResponseEncoder : UpdateFsrsConfigResponse -> Json.Encode.Value
updateFsrsConfigResponseEncoder struct =
    Json.Encode.object
        [ ( "updated_config", (fsrsLanguageConfigEncoder) struct.updatedConfig )
        ]


type alias SetCardStateRequest =
    { cardId : InfluxResourceId
    , newState : CardState
    }


setCardStateRequestEncoder : SetCardStateRequest -> Json.Encode.Value
setCardStateRequestEncoder struct =
    Json.Encode.object
        [ ( "card_id", (influxResourceIdEncoder) struct.cardId )
        , ( "new_state", (cardStateEncoder) struct.newState )
        ]


type alias SetCardStateResponse =
    { updatedCard : Card
    }


setCardStateResponseEncoder : SetCardStateResponse -> Json.Encode.Value
setCardStateResponseEncoder struct =
    Json.Encode.object
        [ ( "updated_card", (cardEncoder) struct.updatedCard )
        ]


type StardictType
    = Html
    | Other (String)


stardictTypeEncoder : StardictType -> Json.Encode.Value
stardictTypeEncoder enum =
    case enum of
        Html ->
            Json.Encode.string "Html"
        Other inner ->
            Json.Encode.object [ ( "Other", Json.Encode.string inner ) ]

type alias WordDefinition =
    { word : String
    , segments : List (WordDefinitionSegment)
    , dictionaryInfo : DictionaryInfo
    }


wordDefinitionEncoder : WordDefinition -> Json.Encode.Value
wordDefinitionEncoder struct =
    Json.Encode.object
        [ ( "word", (Json.Encode.string) struct.word )
        , ( "segments", (Json.Encode.list (wordDefinitionSegmentEncoder)) struct.segments )
        , ( "dictionary_info", (dictionaryInfoEncoder) struct.dictionaryInfo )
        ]


type alias WordDefinitionSegment =
    { types : StardictType
    , text : String
    }


wordDefinitionSegmentEncoder : WordDefinitionSegment -> Json.Encode.Value
wordDefinitionSegmentEncoder struct =
    Json.Encode.object
        [ ( "types", (stardictTypeEncoder) struct.types )
        , ( "text", (Json.Encode.string) struct.text )
        ]


type alias DictionaryInfo =
    { name : String
    , directoryName : String
    , baseUrl : String
    }


dictionaryInfoEncoder : DictionaryInfo -> Json.Encode.Value
dictionaryInfoEncoder struct =
    Json.Encode.object
        [ ( "name", (Json.Encode.string) struct.name )
        , ( "directory_name", (Json.Encode.string) struct.directoryName )
        , ( "base_url", (Json.Encode.string) struct.baseUrl )
        ]


type alias TermDictionary =
    { tokenDict : Dict String (Token)
    , phraseDict : Dict String (Phrase)
    }


termDictionaryEncoder : TermDictionary -> Json.Encode.Value
termDictionaryEncoder struct =
    Json.Encode.object
        [ ( "token_dict", (Json.Encode.dict identity (tokenEncoder)) struct.tokenDict )
        , ( "phrase_dict", (Json.Encode.dict identity (phraseEncoder)) struct.phraseDict )
        ]


type alias AnnotatedDocV2 =
    { text : String
    , segments : List (DocSegV2)
    , orthographySet : List (String)
    , lemmaSet : List (String)
    , parserConfig : ParserConfig
    }


annotatedDocV2Encoder : AnnotatedDocV2 -> Json.Encode.Value
annotatedDocV2Encoder struct =
    Json.Encode.object
        [ ( "text", (Json.Encode.string) struct.text )
        , ( "segments", (Json.Encode.list (docSegV2Encoder)) struct.segments )
        , ( "orthography_set", (Json.Encode.list (Json.Encode.string)) struct.orthographySet )
        , ( "lemma_set", (Json.Encode.list (Json.Encode.string)) struct.lemmaSet )
        , ( "parser_config", (parserConfigEncoder) struct.parserConfig )
        ]


type alias DocSegV2 =
    { text : String
    , startChar : Int
    , endChar : Int
    , inner : DocSegVariants
    }


docSegV2Encoder : DocSegV2 -> Json.Encode.Value
docSegV2Encoder struct =
    Json.Encode.object
        [ ( "text", (Json.Encode.string) struct.text )
        , ( "start_char", (Json.Encode.int) struct.startChar )
        , ( "end_char", (Json.Encode.int) struct.endChar )
        , ( "inner", (docSegVariantsEncoder) struct.inner )
        ]


type DocSegVariants
    = Sentence { segments : List (SentSegV2) }
    | DocumentWhitespace


docSegVariantsEncoder : DocSegVariants -> Json.Encode.Value
docSegVariantsEncoder enum =
    case enum of
        Sentence { segments } ->
            Json.Encode.object [ ( "Sentence", Json.Encode.object [ ( "segments", (Json.Encode.list (sentSegV2Encoder)) segments ) ] ) ]
        DocumentWhitespace ->
            Json.Encode.string "DocumentWhitespace"

type alias SentSegV2 =
    { sentenceIdx : Int
    , text : String
    , startChar : Int
    , endChar : Int
    , inner : SentSegVariants
    , attributes : SegAttribute
    }


sentSegV2Encoder : SentSegV2 -> Json.Encode.Value
sentSegV2Encoder struct =
    Json.Encode.object
        [ ( "sentence_idx", (Json.Encode.int) struct.sentenceIdx )
        , ( "text", (Json.Encode.string) struct.text )
        , ( "start_char", (Json.Encode.int) struct.startChar )
        , ( "end_char", (Json.Encode.int) struct.endChar )
        , ( "inner", (sentSegVariantsEncoder) struct.inner )
        , ( "attributes", (segAttributeEncoder) struct.attributes )
        ]


type SentSegVariants
    = TokenSeg { idx : Int, orthography : String }
    | PhraseSeg { normalisedOrthography : String, components : List (SentSegV2) }
    | WhitespaceSeg
    | PunctuationSeg


sentSegVariantsEncoder : SentSegVariants -> Json.Encode.Value
sentSegVariantsEncoder enum =
    case enum of
        TokenSeg { idx, orthography } ->
            Json.Encode.object [ ( "TokenSeg", Json.Encode.object [ ( "idx", (Json.Encode.int) idx ), ( "orthography", (Json.Encode.string) orthography ) ] ) ]
        PhraseSeg { normalisedOrthography, components } ->
            Json.Encode.object [ ( "PhraseSeg", Json.Encode.object [ ( "normalised_orthography", (Json.Encode.string) normalisedOrthography ), ( "components", (Json.Encode.list (sentSegV2Encoder)) components ) ] ) ]
        WhitespaceSeg ->
            Json.Encode.string "WhitespaceSeg"
        PunctuationSeg ->
            Json.Encode.string "PunctuationSeg"

type alias SegAttribute =
    { lemma : Maybe (String)
    , upos : Maybe (String)
    , xpos : Maybe (String)
    , dependency : Maybe (( Int, String ))
    , misc : Dict String (String)
    , conjugationChain : Maybe (List (ConjugationStep))
    }


segAttributeEncoder : SegAttribute -> Json.Encode.Value
segAttributeEncoder struct =
    Json.Encode.object
        [ ( "lemma", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.lemma )
        , ( "upos", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.upos )
        , ( "xpos", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.string)) struct.xpos )
        , ( "dependency", (Maybe.withDefault Json.Encode.null << Maybe.map (\( a, b) -> Json.Encode.list identity [ Json.Encode.int a, Json.Encode.string b ])) struct.dependency )
        , ( "misc", (Json.Encode.dict identity (Json.Encode.string)) struct.misc )
        , ( "conjugation_chain", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.list (conjugationStepEncoder))) struct.conjugationChain )
        ]


type alias ConjugationStep =
    { step : Int
    , form : String
    , result : String
    }


conjugationStepEncoder : ConjugationStep -> Json.Encode.Value
conjugationStepEncoder struct =
    Json.Encode.object
        [ ( "step", (Json.Encode.int) struct.step )
        , ( "form", (Json.Encode.string) struct.form )
        , ( "result", (Json.Encode.string) struct.result )
        ]


influxResourceIdDecoder : Json.Decode.Decoder InfluxResourceId
influxResourceIdDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.map SerialId (Json.Decode.field "SerialId" (Json.Decode.int))
        , Json.Decode.map StringId (Json.Decode.field "StringId" (Json.Decode.string))
        ]

languageDecoder : Json.Decode.Decoder Language
languageDecoder =
    Json.Decode.succeed Language
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "name" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "dicts" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tts_rate" (Json.Decode.nullable (Json.Decode.float))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tts_pitch" (Json.Decode.nullable (Json.Decode.float))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tts_voice" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "deepl_source_lang" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "deepl_target_lang" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "parser_config" (parserConfigDecoder)))


parserConfigDecoder : Json.Decode.Decoder ParserConfig
parserConfigDecoder =
    Json.Decode.succeed ParserConfig
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "which_parser" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "parser_args" (Json.Decode.dict (Json.Decode.string))))


documentDecoder : Json.Decode.Decoder Document
documentDecoder =
    Json.Decode.succeed Document
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "title" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "content" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "doc_type" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tags" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "created_ts" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_ts" (Json.Decode.string)))


documentCreateRequestDecoder : Json.Decode.Decoder DocumentCreateRequest
documentCreateRequestDecoder =
    Json.Decode.succeed DocumentCreateRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "title" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "content" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "doc_type" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tags" (Json.Decode.list (Json.Decode.string))))


docPackageDecoder : Json.Decode.Decoder DocPackage
docPackageDecoder =
    Json.Decode.succeed DocPackage
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "document_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "language_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "document" (documentDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "language" (languageDecoder)))


tokenDecoder : Json.Decode.Decoder Token
tokenDecoder =
    Json.Decode.succeed Token
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "phonetic" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "definition" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "notes" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "original_context" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "status" (tokenStatusDecoder)))


tokenStatusDecoder : Json.Decode.Decoder TokenStatus
tokenStatusDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "UNMARKED" ->
                            Json.Decode.succeed Unmarked
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L1" ->
                            Json.Decode.succeed L1
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L2" ->
                            Json.Decode.succeed L2
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L3" ->
                            Json.Decode.succeed L3
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L4" ->
                            Json.Decode.succeed L4
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L5" ->
                            Json.Decode.succeed L5
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "KNOWN" ->
                            Json.Decode.succeed Known
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "IGNORED" ->
                            Json.Decode.succeed Ignored
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

phraseDecoder : Json.Decode.Decoder Phrase
phraseDecoder =
    Json.Decode.succeed Phrase
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography_seq" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "definition" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "notes" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "original_context" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "status" (tokenStatusDecoder)))


cardTypeDecoder : Json.Decode.Decoder CardType
cardTypeDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "RECOGNITION" ->
                            Json.Decode.succeed Recognition
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "PRODUCTION" ->
                            Json.Decode.succeed Production
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "CLOZE" ->
                            Json.Decode.succeed Cloze
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

cardStateDecoder : Json.Decode.Decoder CardState
cardStateDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "ACTIVE" ->
                            Json.Decode.succeed Active
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "SUSPENDED" ->
                            Json.Decode.succeed Suspended
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "ARCHIVED" ->
                            Json.Decode.succeed Archived
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "DISABLED" ->
                            Json.Decode.succeed Disabled
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

fsrsLanguageConfigDecoder : Json.Decode.Decoder FsrsLanguageConfig
fsrsLanguageConfigDecoder =
    Json.Decode.succeed FsrsLanguageConfig
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "fsrs_weights" (Json.Decode.list (Json.Decode.float))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "desired_retention" (Json.Decode.float)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "maximum_interval" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "request_retention" (Json.Decode.nullable (Json.Decode.float))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "enabled_card_types" (Json.Decode.list (cardTypeDecoder))))


cardDecoder : Json.Decode.Decoder Card
cardDecoder =
    Json.Decode.succeed Card
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "token_id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "phrase_id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_type" (cardTypeDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_state" (cardStateDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "fsrs_memory" (Json.Decode.nullable (serializableMemoryStateDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "due_date" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "last_review" (Json.Decode.nullable (Json.Decode.string))))


reviewLogDecoder : Json.Decode.Decoder ReviewLog
reviewLogDecoder =
    Json.Decode.succeed ReviewLog
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable (influxResourceIdDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "rating" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "review_time_ms" (Json.Decode.nullable (Json.Decode.int))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "fsrs_memory_before" (Json.Decode.nullable (serializableMemoryStateDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "fsrs_memory_after" (Json.Decode.nullable (serializableMemoryStateDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "review_date" (Json.Decode.string)))


serializableMemoryStateDecoder : Json.Decode.Decoder SerializableMemoryState
serializableMemoryStateDecoder =
    Json.Decode.succeed SerializableMemoryState
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "stability" (Json.Decode.float)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "difficulty" (Json.Decode.float)))


termDecoder : Json.Decode.Decoder Term
termDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.map TokenTerm (Json.Decode.field "TokenTerm" (tokenDecoder))
        , Json.Decode.map PhraseTerm (Json.Decode.field "PhraseTerm" (phraseDecoder))
        ]

termEditActionDecoder : Json.Decode.Decoder TermEditAction
termEditActionDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "CreateTerm" ->
                            Json.Decode.succeed CreateTerm
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "UpdateTerm" ->
                            Json.Decode.succeed UpdateTerm
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "DeleteTerm" ->
                            Json.Decode.succeed DeleteTerm
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

getDocResponseDecoder : Json.Decode.Decoder GetDocResponse
getDocResponseDecoder =
    Json.Decode.succeed GetDocResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "doc_package" (docPackageDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "annotated_doc" (annotatedDocV2Decoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term_dict" (termDictionaryDecoder)))


termEditRequestDecoder : Json.Decode.Decoder TermEditRequest
termEditRequestDecoder =
    Json.Decode.succeed TermEditRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "requested_action" (termEditActionDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term" (termDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "document_id" (Json.Decode.nullable (influxResourceIdDecoder))))


termEditResponseDecoder : Json.Decode.Decoder TermEditResponse
termEditResponseDecoder =
    Json.Decode.succeed TermEditResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "performed_action" (termEditActionDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term" (termDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_annotated_doc" (Json.Decode.nullable (annotatedDocV2Decoder))))


getDocsRequestDecoder : Json.Decode.Decoder GetDocsRequest
getDocsRequestDecoder =
    Json.Decode.succeed GetDocsRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "language_id" (Json.Decode.nullable (influxResourceIdDecoder))))


reviewableCardIdDecoder : Json.Decode.Decoder ReviewableCardId
reviewableCardIdDecoder = 
        let
            elmRsConstructNewTokenCard tokenId cardType =
                        NewTokenCard { tokenId = tokenId, cardType = cardType }
            elmRsConstructNewPhraseCard phraseId cardType =
                        NewPhraseCard { phraseId = phraseId, cardType = cardType }
        in
    Json.Decode.oneOf
        [ Json.Decode.map ExistingCard (Json.Decode.field "ExistingCard" (influxResourceIdDecoder))
        , Json.Decode.field "NewTokenCard" (Json.Decode.succeed elmRsConstructNewTokenCard |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "token_id" (influxResourceIdDecoder))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_type" (cardTypeDecoder))))
        , Json.Decode.field "NewPhraseCard" (Json.Decode.succeed elmRsConstructNewPhraseCard |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "phrase_id" (influxResourceIdDecoder))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_type" (cardTypeDecoder))))
        ]

cardWithTermDecoder : Json.Decode.Decoder CardWithTerm
cardWithTermDecoder =
    Json.Decode.succeed CardWithTerm
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card" (cardDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term" (termDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "is_new_card" (Json.Decode.bool)))


getNextDueCardRequestDecoder : Json.Decode.Decoder GetNextDueCardRequest
getNextDueCardRequestDecoder =
    Json.Decode.succeed GetNextDueCardRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_types" (Json.Decode.nullable (Json.Decode.list (cardTypeDecoder)))))


getNextDueCardResponseDecoder : Json.Decode.Decoder GetNextDueCardResponse
getNextDueCardResponseDecoder =
    Json.Decode.succeed GetNextDueCardResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card" (Json.Decode.nullable (cardWithTermDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "remaining_due_count" (Json.Decode.int)))


submitReviewRequestDecoder : Json.Decode.Decoder SubmitReviewRequest
submitReviewRequestDecoder =
    Json.Decode.succeed SubmitReviewRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_identifier" (reviewableCardIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "rating" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "review_time_ms" (Json.Decode.nullable (Json.Decode.int))))


submitReviewResponseDecoder : Json.Decode.Decoder SubmitReviewResponse
submitReviewResponseDecoder =
    Json.Decode.succeed SubmitReviewResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_card" (cardDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "review_log" (reviewLogDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "next_due_date" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "was_new_card" (Json.Decode.bool)))


updateFsrsConfigRequestDecoder : Json.Decode.Decoder UpdateFsrsConfigRequest
updateFsrsConfigRequestDecoder =
    Json.Decode.succeed UpdateFsrsConfigRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "new_config" (fsrsLanguageConfigDecoder)))


updateFsrsConfigResponseDecoder : Json.Decode.Decoder UpdateFsrsConfigResponse
updateFsrsConfigResponseDecoder =
    Json.Decode.succeed UpdateFsrsConfigResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_config" (fsrsLanguageConfigDecoder)))


setCardStateRequestDecoder : Json.Decode.Decoder SetCardStateRequest
setCardStateRequestDecoder =
    Json.Decode.succeed SetCardStateRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "card_id" (influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "new_state" (cardStateDecoder)))


setCardStateResponseDecoder : Json.Decode.Decoder SetCardStateResponse
setCardStateResponseDecoder =
    Json.Decode.succeed SetCardStateResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_card" (cardDecoder)))


stardictTypeDecoder : Json.Decode.Decoder StardictType
stardictTypeDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "Html" ->
                            Json.Decode.succeed Html
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.map Other (Json.Decode.field "Other" (Json.Decode.string))
        ]

wordDefinitionDecoder : Json.Decode.Decoder WordDefinition
wordDefinitionDecoder =
    Json.Decode.succeed WordDefinition
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "word" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "segments" (Json.Decode.list (wordDefinitionSegmentDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "dictionary_info" (dictionaryInfoDecoder)))


wordDefinitionSegmentDecoder : Json.Decode.Decoder WordDefinitionSegment
wordDefinitionSegmentDecoder =
    Json.Decode.succeed WordDefinitionSegment
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "types" (stardictTypeDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" (Json.Decode.string)))


dictionaryInfoDecoder : Json.Decode.Decoder DictionaryInfo
dictionaryInfoDecoder =
    Json.Decode.succeed DictionaryInfo
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "name" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "directory_name" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "base_url" (Json.Decode.string)))


termDictionaryDecoder : Json.Decode.Decoder TermDictionary
termDictionaryDecoder =
    Json.Decode.succeed TermDictionary
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "token_dict" (Json.Decode.dict (tokenDecoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "phrase_dict" (Json.Decode.dict (phraseDecoder))))


annotatedDocV2Decoder : Json.Decode.Decoder AnnotatedDocV2
annotatedDocV2Decoder =
    Json.Decode.succeed AnnotatedDocV2
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "segments" (Json.Decode.list (docSegV2Decoder))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography_set" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lemma_set" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "parser_config" (parserConfigDecoder)))


docSegV2Decoder : Json.Decode.Decoder DocSegV2
docSegV2Decoder =
    Json.Decode.succeed DocSegV2
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "start_char" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "end_char" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "inner" (docSegVariantsDecoder)))


docSegVariantsDecoder : Json.Decode.Decoder DocSegVariants
docSegVariantsDecoder = 
        let
            elmRsConstructSentence segments =
                        Sentence { segments = segments }
        in
    Json.Decode.oneOf
        [ Json.Decode.field "Sentence" (Json.Decode.succeed elmRsConstructSentence |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "segments" (Json.Decode.list (sentSegV2Decoder)))))
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "DocumentWhitespace" ->
                            Json.Decode.succeed DocumentWhitespace
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

sentSegV2Decoder : Json.Decode.Decoder SentSegV2
sentSegV2Decoder =
    Json.Decode.succeed SentSegV2
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "sentence_idx" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "start_char" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "end_char" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "inner" (sentSegVariantsDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "attributes" (segAttributeDecoder)))


sentSegVariantsDecoder : Json.Decode.Decoder SentSegVariants
sentSegVariantsDecoder = 
        let
            elmRsConstructTokenSeg idx orthography =
                        TokenSeg { idx = idx, orthography = orthography }
            elmRsConstructPhraseSeg normalisedOrthography components =
                        PhraseSeg { normalisedOrthography = normalisedOrthography, components = components }
        in
    Json.Decode.oneOf
        [ Json.Decode.field "TokenSeg" (Json.Decode.succeed elmRsConstructTokenSeg |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "idx" (Json.Decode.int))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography" (Json.Decode.string))))
        , Json.Decode.field "PhraseSeg" (Json.Decode.succeed elmRsConstructPhraseSeg |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "normalised_orthography" (Json.Decode.string))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "components" (Json.Decode.list (sentSegV2Decoder)))))
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "WhitespaceSeg" ->
                            Json.Decode.succeed WhitespaceSeg
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "PunctuationSeg" ->
                            Json.Decode.succeed PunctuationSeg
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

segAttributeDecoder : Json.Decode.Decoder SegAttribute
segAttributeDecoder =
    Json.Decode.succeed SegAttribute
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lemma" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "upos" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "xpos" (Json.Decode.nullable (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "dependency" (Json.Decode.nullable (Json.Decode.map2 (\a b -> ( a, b )) (Json.Decode.index 0 (Json.Decode.int)) (Json.Decode.index 1 (Json.Decode.string))))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "misc" (Json.Decode.dict (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "conjugation_chain" (Json.Decode.nullable (Json.Decode.list (conjugationStepDecoder)))))


conjugationStepDecoder : Json.Decode.Decoder ConjugationStep
conjugationStepDecoder =
    Json.Decode.succeed ConjugationStep
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "step" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "form" (Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "result" (Json.Decode.string)))


