-- generated by elm_rs


module Bindings exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]

        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type InfluxResourceId
    = SerialId Int
    | StringId String


influxResourceIdEncoder : InfluxResourceId -> Json.Encode.Value
influxResourceIdEncoder enum =
    case enum of
        SerialId inner ->
            Json.Encode.object [ ( "SerialId", Json.Encode.int inner ) ]

        StringId inner ->
            Json.Encode.object [ ( "StringId", Json.Encode.string inner ) ]


type alias LanguageEntry =
    { id : Maybe InfluxResourceId
    , code : String
    , name : String
    , dicts : List String
    , ttsRate : Maybe Float
    , ttsPitch : Maybe Float
    , ttsVoice : Maybe String
    }


languageEntryEncoder : LanguageEntry -> Json.Encode.Value
languageEntryEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map influxResourceIdEncoder) struct.id )
        , ( "code", Json.Encode.string struct.code )
        , ( "name", Json.Encode.string struct.name )
        , ( "dicts", Json.Encode.list Json.Encode.string struct.dicts )
        , ( "tts_rate", (Maybe.withDefault Json.Encode.null << Maybe.map Json.Encode.float) struct.ttsRate )
        , ( "tts_pitch", (Maybe.withDefault Json.Encode.null << Maybe.map Json.Encode.float) struct.ttsPitch )
        , ( "tts_voice", (Maybe.withDefault Json.Encode.null << Maybe.map Json.Encode.string) struct.ttsVoice )
        ]


type alias Document =
    { id : Maybe InfluxResourceId
    , langId : InfluxResourceId
    , title : String
    , content : String
    , docType : String
    , tags : List String
    , createdTs : String
    , updatedTs : String
    }


documentEncoder : Document -> Json.Encode.Value
documentEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map influxResourceIdEncoder) struct.id )
        , ( "lang_id", influxResourceIdEncoder struct.langId )
        , ( "title", Json.Encode.string struct.title )
        , ( "content", Json.Encode.string struct.content )
        , ( "doc_type", Json.Encode.string struct.docType )
        , ( "tags", Json.Encode.list Json.Encode.string struct.tags )
        , ( "created_ts", Json.Encode.string struct.createdTs )
        , ( "updated_ts", Json.Encode.string struct.updatedTs )
        ]


type alias DocPackage =
    { documentId : InfluxResourceId
    , languageId : InfluxResourceId
    , document : Document
    , language : LanguageEntry
    }


docPackageEncoder : DocPackage -> Json.Encode.Value
docPackageEncoder struct =
    Json.Encode.object
        [ ( "document_id", influxResourceIdEncoder struct.documentId )
        , ( "language_id", influxResourceIdEncoder struct.languageId )
        , ( "document", documentEncoder struct.document )
        , ( "language", languageEntryEncoder struct.language )
        ]


type alias Token =
    { id : Maybe InfluxResourceId
    , langId : InfluxResourceId
    , orthography : String
    , phonetic : String
    , definition : String
    , notes : String
    , originalContext : String
    , status : TokenStatus
    }


tokenEncoder : Token -> Json.Encode.Value
tokenEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map influxResourceIdEncoder) struct.id )
        , ( "lang_id", influxResourceIdEncoder struct.langId )
        , ( "orthography", Json.Encode.string struct.orthography )
        , ( "phonetic", Json.Encode.string struct.phonetic )
        , ( "definition", Json.Encode.string struct.definition )
        , ( "notes", Json.Encode.string struct.notes )
        , ( "original_context", Json.Encode.string struct.originalContext )
        , ( "status", tokenStatusEncoder struct.status )
        ]


type TokenStatus
    = Unmarked
    | L1
    | L2
    | L3
    | L4
    | L5
    | Known
    | Ignored


tokenStatusEncoder : TokenStatus -> Json.Encode.Value
tokenStatusEncoder enum =
    case enum of
        Unmarked ->
            Json.Encode.string "UNMARKED"

        L1 ->
            Json.Encode.string "L1"

        L2 ->
            Json.Encode.string "L2"

        L3 ->
            Json.Encode.string "L3"

        L4 ->
            Json.Encode.string "L4"

        L5 ->
            Json.Encode.string "L5"

        Known ->
            Json.Encode.string "KNOWN"

        Ignored ->
            Json.Encode.string "IGNORED"


type alias Phrase =
    { id : Maybe InfluxResourceId
    , langId : InfluxResourceId
    , orthographySeq : List String
    , definition : String
    , notes : String
    , originalContext : String
    , status : TokenStatus
    }


phraseEncoder : Phrase -> Json.Encode.Value
phraseEncoder struct =
    Json.Encode.object
        [ ( "id", (Maybe.withDefault Json.Encode.null << Maybe.map influxResourceIdEncoder) struct.id )
        , ( "lang_id", influxResourceIdEncoder struct.langId )
        , ( "orthography_seq", Json.Encode.list Json.Encode.string struct.orthographySeq )
        , ( "definition", Json.Encode.string struct.definition )
        , ( "notes", Json.Encode.string struct.notes )
        , ( "original_context", Json.Encode.string struct.originalContext )
        , ( "status", tokenStatusEncoder struct.status )
        ]


type Term
    = TokenTerm Token
    | PhraseTerm Phrase


termEncoder : Term -> Json.Encode.Value
termEncoder enum =
    case enum of
        TokenTerm inner ->
            Json.Encode.object [ ( "TokenTerm", tokenEncoder inner ) ]

        PhraseTerm inner ->
            Json.Encode.object [ ( "PhraseTerm", phraseEncoder inner ) ]


type TermEditAction
    = CreateTerm
    | UpdateTerm
    | DeleteTerm


termEditActionEncoder : TermEditAction -> Json.Encode.Value
termEditActionEncoder enum =
    case enum of
        CreateTerm ->
            Json.Encode.string "CreateTerm"

        UpdateTerm ->
            Json.Encode.string "UpdateTerm"

        DeleteTerm ->
            Json.Encode.string "DeleteTerm"


type alias GetDocResponse =
    { docPackage : DocPackage
    , annotatedDoc : AnnotatedDocV2
    , termDict : TermDictionary
    }


getDocResponseEncoder : GetDocResponse -> Json.Encode.Value
getDocResponseEncoder struct =
    Json.Encode.object
        [ ( "doc_package", docPackageEncoder struct.docPackage )
        , ( "annotated_doc", annotatedDocV2Encoder struct.annotatedDoc )
        , ( "term_dict", termDictionaryEncoder struct.termDict )
        ]


type alias TermEditRequest =
    { requestedAction : TermEditAction
    , term : Term
    , documentId : Maybe InfluxResourceId
    }


termEditRequestEncoder : TermEditRequest -> Json.Encode.Value
termEditRequestEncoder struct =
    Json.Encode.object
        [ ( "requested_action", termEditActionEncoder struct.requestedAction )
        , ( "term", termEncoder struct.term )
        , ( "document_id", (Maybe.withDefault Json.Encode.null << Maybe.map influxResourceIdEncoder) struct.documentId )
        ]


type alias TermEditResponse =
    { performedAction : TermEditAction
    , term : Term
    , updatedAnnotatedDoc : Maybe AnnotatedDocV2
    }


termEditResponseEncoder : TermEditResponse -> Json.Encode.Value
termEditResponseEncoder struct =
    Json.Encode.object
        [ ( "performed_action", termEditActionEncoder struct.performedAction )
        , ( "term", termEncoder struct.term )
        , ( "updated_annotated_doc", (Maybe.withDefault Json.Encode.null << Maybe.map annotatedDocV2Encoder) struct.updatedAnnotatedDoc )
        ]


type alias GetDocsRequest =
    { languageId : Maybe InfluxResourceId
    }


getDocsRequestEncoder : GetDocsRequest -> Json.Encode.Value
getDocsRequestEncoder struct =
    Json.Encode.object
        [ ( "language_id", (Maybe.withDefault Json.Encode.null << Maybe.map influxResourceIdEncoder) struct.languageId )
        ]


type alias TermDictionary =
    { tokenDict : Dict String Token
    , phraseDict : Dict String Phrase
    }


termDictionaryEncoder : TermDictionary -> Json.Encode.Value
termDictionaryEncoder struct =
    Json.Encode.object
        [ ( "token_dict", Json.Encode.dict identity tokenEncoder struct.tokenDict )
        , ( "phrase_dict", Json.Encode.dict identity phraseEncoder struct.phraseDict )
        ]


type alias DocPath =
    { lang : String
    , file : String
    }


docPathEncoder : DocPath -> Json.Encode.Value
docPathEncoder struct =
    Json.Encode.object
        [ ( "lang", Json.Encode.string struct.lang )
        , ( "file", Json.Encode.string struct.file )
        ]


type alias AnnotatedDocV2 =
    { text : String
    , segments : List DocSegV2
    , orthographySet : List String
    , lemmaSet : List String
    }


annotatedDocV2Encoder : AnnotatedDocV2 -> Json.Encode.Value
annotatedDocV2Encoder struct =
    Json.Encode.object
        [ ( "text", Json.Encode.string struct.text )
        , ( "segments", Json.Encode.list docSegV2Encoder struct.segments )
        , ( "orthography_set", Json.Encode.list Json.Encode.string struct.orthographySet )
        , ( "lemma_set", Json.Encode.list Json.Encode.string struct.lemmaSet )
        ]


type alias DocSegV2 =
    { text : String
    , startChar : Int
    , endChar : Int
    , inner : DocSegVariants
    }


docSegV2Encoder : DocSegV2 -> Json.Encode.Value
docSegV2Encoder struct =
    Json.Encode.object
        [ ( "text", Json.Encode.string struct.text )
        , ( "start_char", Json.Encode.int struct.startChar )
        , ( "end_char", Json.Encode.int struct.endChar )
        , ( "inner", docSegVariantsEncoder struct.inner )
        ]


type DocSegVariants
    = Sentence { segments : List SentSegV2 }
    | DocumentWhitespace


docSegVariantsEncoder : DocSegVariants -> Json.Encode.Value
docSegVariantsEncoder enum =
    case enum of
        Sentence { segments } ->
            Json.Encode.object [ ( "Sentence", Json.Encode.object [ ( "segments", Json.Encode.list sentSegV2Encoder segments ) ] ) ]

        DocumentWhitespace ->
            Json.Encode.string "DocumentWhitespace"


type alias SentSegV2 =
    { sentenceIdx : Int
    , text : String
    , startChar : Int
    , endChar : Int
    , inner : SentSegVariants
    , attributes : SegAttribute
    }


sentSegV2Encoder : SentSegV2 -> Json.Encode.Value
sentSegV2Encoder struct =
    Json.Encode.object
        [ ( "sentence_idx", Json.Encode.int struct.sentenceIdx )
        , ( "text", Json.Encode.string struct.text )
        , ( "start_char", Json.Encode.int struct.startChar )
        , ( "end_char", Json.Encode.int struct.endChar )
        , ( "inner", sentSegVariantsEncoder struct.inner )
        , ( "attributes", segAttributeEncoder struct.attributes )
        ]


type SentSegVariants
    = TokenSeg { idx : Int, orthography : String }
    | PhraseSeg { normalisedOrthography : String, components : List SentSegV2 }
    | WhitespaceSeg
    | PunctuationSeg


sentSegVariantsEncoder : SentSegVariants -> Json.Encode.Value
sentSegVariantsEncoder enum =
    case enum of
        TokenSeg { idx, orthography } ->
            Json.Encode.object [ ( "TokenSeg", Json.Encode.object [ ( "idx", Json.Encode.int idx ), ( "orthography", Json.Encode.string orthography ) ] ) ]

        PhraseSeg { normalisedOrthography, components } ->
            Json.Encode.object [ ( "PhraseSeg", Json.Encode.object [ ( "normalised_orthography", Json.Encode.string normalisedOrthography ), ( "components", Json.Encode.list sentSegV2Encoder components ) ] ) ]

        WhitespaceSeg ->
            Json.Encode.string "WhitespaceSeg"

        PunctuationSeg ->
            Json.Encode.string "PunctuationSeg"


type alias SegAttribute =
    { lemma : Maybe String
    , upos : Maybe String
    , xpos : Maybe String
    , dependency : Maybe ( Int, String )
    , misc : Dict String String
    }


segAttributeEncoder : SegAttribute -> Json.Encode.Value
segAttributeEncoder struct =
    Json.Encode.object
        [ ( "lemma", (Maybe.withDefault Json.Encode.null << Maybe.map Json.Encode.string) struct.lemma )
        , ( "upos", (Maybe.withDefault Json.Encode.null << Maybe.map Json.Encode.string) struct.upos )
        , ( "xpos", (Maybe.withDefault Json.Encode.null << Maybe.map Json.Encode.string) struct.xpos )
        , ( "dependency", (Maybe.withDefault Json.Encode.null << Maybe.map (\( a, b ) -> Json.Encode.list identity [ Json.Encode.int a, Json.Encode.string b ])) struct.dependency )
        , ( "misc", Json.Encode.dict identity Json.Encode.string struct.misc )
        ]


influxResourceIdDecoder : Json.Decode.Decoder InfluxResourceId
influxResourceIdDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map SerialId (Json.Decode.field "SerialId" Json.Decode.int)
        , Json.Decode.map StringId (Json.Decode.field "StringId" Json.Decode.string)
        ]


languageEntryDecoder : Json.Decode.Decoder LanguageEntry
languageEntryDecoder =
    Json.Decode.succeed LanguageEntry
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "code" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "name" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "dicts" (Json.Decode.list Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tts_rate" (Json.Decode.nullable Json.Decode.float)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tts_pitch" (Json.Decode.nullable Json.Decode.float)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tts_voice" (Json.Decode.nullable Json.Decode.string)))


documentDecoder : Json.Decode.Decoder Document
documentDecoder =
    Json.Decode.succeed Document
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" influxResourceIdDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "title" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "content" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "doc_type" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "tags" (Json.Decode.list Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "created_ts" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_ts" Json.Decode.string))


docPackageDecoder : Json.Decode.Decoder DocPackage
docPackageDecoder =
    Json.Decode.succeed DocPackage
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "document_id" influxResourceIdDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "language_id" influxResourceIdDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "document" documentDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "language" languageEntryDecoder))


tokenDecoder : Json.Decode.Decoder Token
tokenDecoder =
    Json.Decode.succeed Token
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" influxResourceIdDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "phonetic" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "definition" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "notes" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "original_context" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "status" tokenStatusDecoder))


tokenStatusDecoder : Json.Decode.Decoder TokenStatus
tokenStatusDecoder =
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "UNMARKED" ->
                            Json.Decode.succeed Unmarked

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L1" ->
                            Json.Decode.succeed L1

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L2" ->
                            Json.Decode.succeed L2

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L3" ->
                            Json.Decode.succeed L3

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L4" ->
                            Json.Decode.succeed L4

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "L5" ->
                            Json.Decode.succeed L5

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "KNOWN" ->
                            Json.Decode.succeed Known

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "IGNORED" ->
                            Json.Decode.succeed Ignored

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]


phraseDecoder : Json.Decode.Decoder Phrase
phraseDecoder =
    Json.Decode.succeed Phrase
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.nullable influxResourceIdDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang_id" influxResourceIdDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography_seq" (Json.Decode.list Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "definition" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "notes" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "original_context" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "status" tokenStatusDecoder))


termDecoder : Json.Decode.Decoder Term
termDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map TokenTerm (Json.Decode.field "TokenTerm" tokenDecoder)
        , Json.Decode.map PhraseTerm (Json.Decode.field "PhraseTerm" phraseDecoder)
        ]


termEditActionDecoder : Json.Decode.Decoder TermEditAction
termEditActionDecoder =
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "CreateTerm" ->
                            Json.Decode.succeed CreateTerm

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "UpdateTerm" ->
                            Json.Decode.succeed UpdateTerm

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "DeleteTerm" ->
                            Json.Decode.succeed DeleteTerm

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]


getDocResponseDecoder : Json.Decode.Decoder GetDocResponse
getDocResponseDecoder =
    Json.Decode.succeed GetDocResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "doc_package" docPackageDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "annotated_doc" annotatedDocV2Decoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term_dict" termDictionaryDecoder))


termEditRequestDecoder : Json.Decode.Decoder TermEditRequest
termEditRequestDecoder =
    Json.Decode.succeed TermEditRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "requested_action" termEditActionDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term" termDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "document_id" (Json.Decode.nullable influxResourceIdDecoder)))


termEditResponseDecoder : Json.Decode.Decoder TermEditResponse
termEditResponseDecoder =
    Json.Decode.succeed TermEditResponse
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "performed_action" termEditActionDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "term" termDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "updated_annotated_doc" (Json.Decode.nullable annotatedDocV2Decoder)))


getDocsRequestDecoder : Json.Decode.Decoder GetDocsRequest
getDocsRequestDecoder =
    Json.Decode.succeed GetDocsRequest
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "language_id" (Json.Decode.nullable influxResourceIdDecoder)))


termDictionaryDecoder : Json.Decode.Decoder TermDictionary
termDictionaryDecoder =
    Json.Decode.succeed TermDictionary
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "token_dict" (Json.Decode.dict tokenDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "phrase_dict" (Json.Decode.dict phraseDecoder)))


docPathDecoder : Json.Decode.Decoder DocPath
docPathDecoder =
    Json.Decode.succeed DocPath
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lang" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "file" Json.Decode.string))


annotatedDocV2Decoder : Json.Decode.Decoder AnnotatedDocV2
annotatedDocV2Decoder =
    Json.Decode.succeed AnnotatedDocV2
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "segments" (Json.Decode.list docSegV2Decoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography_set" (Json.Decode.list Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lemma_set" (Json.Decode.list Json.Decode.string)))


docSegV2Decoder : Json.Decode.Decoder DocSegV2
docSegV2Decoder =
    Json.Decode.succeed DocSegV2
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "start_char" Json.Decode.int))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "end_char" Json.Decode.int))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "inner" docSegVariantsDecoder))


docSegVariantsDecoder : Json.Decode.Decoder DocSegVariants
docSegVariantsDecoder =
    let
        elmRsConstructSentence segments =
            Sentence { segments = segments }
    in
    Json.Decode.oneOf
        [ Json.Decode.field "Sentence" (Json.Decode.succeed elmRsConstructSentence |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "segments" (Json.Decode.list sentSegV2Decoder))))
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "DocumentWhitespace" ->
                            Json.Decode.succeed DocumentWhitespace

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]


sentSegV2Decoder : Json.Decode.Decoder SentSegV2
sentSegV2Decoder =
    Json.Decode.succeed SentSegV2
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "sentence_idx" Json.Decode.int))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "text" Json.Decode.string))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "start_char" Json.Decode.int))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "end_char" Json.Decode.int))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "inner" sentSegVariantsDecoder))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "attributes" segAttributeDecoder))


sentSegVariantsDecoder : Json.Decode.Decoder SentSegVariants
sentSegVariantsDecoder =
    let
        elmRsConstructTokenSeg idx orthography =
            TokenSeg { idx = idx, orthography = orthography }

        elmRsConstructPhraseSeg normalisedOrthography components =
            PhraseSeg { normalisedOrthography = normalisedOrthography, components = components }
    in
    Json.Decode.oneOf
        [ Json.Decode.field "TokenSeg" (Json.Decode.succeed elmRsConstructTokenSeg |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "idx" Json.Decode.int)) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "orthography" Json.Decode.string)))
        , Json.Decode.field "PhraseSeg" (Json.Decode.succeed elmRsConstructPhraseSeg |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "normalised_orthography" Json.Decode.string)) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "components" (Json.Decode.list sentSegV2Decoder))))
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "WhitespaceSeg" ->
                            Json.Decode.succeed WhitespaceSeg

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "PunctuationSeg" ->
                            Json.Decode.succeed PunctuationSeg

                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]


segAttributeDecoder : Json.Decode.Decoder SegAttribute
segAttributeDecoder =
    Json.Decode.succeed SegAttribute
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "lemma" (Json.Decode.nullable Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "upos" (Json.Decode.nullable Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "xpos" (Json.Decode.nullable Json.Decode.string)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "dependency" (Json.Decode.nullable (Json.Decode.map2 (\a b -> ( a, b )) (Json.Decode.index 0 Json.Decode.int) (Json.Decode.index 1 Json.Decode.string)))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "misc" (Json.Decode.dict Json.Decode.string)))
